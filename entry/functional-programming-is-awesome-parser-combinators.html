<!DOCTYPE HTML>
<html><head><title>Functional Programming is Awesome: Parser Combinators · in Code</title><meta name="description" content="Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge."><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta property="og:site_name" content="in Code"><meta property="og:description" content="If you’ve spent your entire life programming imperatively, you could not even begin to imagine the vast worlds of thinking that are inaccessible because of restrictions in your thinking. Not better, or harder ways of thinking — possibly just as easy, but…different. Don’t believe me? Here is an example of an amazingly awesome and amazing and incomprehensibly mind-opeining design pattern that shines in functional programming: applicative combinators. In specific, we are going to write a small parser library! Yay!"><meta property="og:type" content="article"><meta property="og:title" content="Functional Programming is Awesome: Parser Combinators"><meta property="og:image" content="http://home.jle0.com:4111/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="http://home.jle0.com:4111/entry/functional-programming-is-awesome-parser-combinators.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/justinleblogdevelopment"><link rel="canonical" href="http://home.jle0.com:4111/entry/functional-programming-is-awesome-parser-combinators.html"><link href="http://home.jle0.com:4111/favicon.ico" rel="shortcut icon"><link href="http://home.jle0.com:4111/css/toast.css" rel="stylesheet" type="text/css"><link href="http://home.jle0.com:4111/css/font.css" rel="stylesheet" type="text/css"><link href="http://home.jle0.com:4111/css/main.css" rel="stylesheet" type="text/css"><link href="http://home.jle0.com:4111/css/page/entry.css" rel="stylesheet" type="text/css"><link href="http://home.jle0.com:4111/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='justinleblogdevelopment';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-7', 'jle0.com');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-520df7c304b817b9"></script><script type="text/javascript" src="http://home.jle0.com:4111/js/page/entry_toc.js"></script><script type="text/javascript" src="http://home.jle0.com:4111/js/disqus_count.js"></script><script type="text/javascript" src="http://home.jle0.com:4111/js/social.js"></script><script type="text/javascript" src="http://home.jle0.com:4111/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="http://home.jle0.com:4111/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=645245675494525";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="http://home.jle0.com:4111/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="http://home.jle0.com:4111/">home</a></li><li><a href="http://home.jle0.com:4111/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">Functional Programming is Awesome: Parser Combinators</h1><p class="entry-info">by <a class="author" href="http://home.jle0.com:4111/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2016-02-20T21:10:53Z" pubdate="" class="pubdate">Saturday February 20, 2016</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/blog/tree/develop/copy/entries/combinators-parsers.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/blog/tree/gh-pages/entry/functional-programming-is-awesome-parser-combinators.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="http://home.jle0.com:4111/entry/functional-programming-is-awesome-parser-combinators.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="http://home.jle0.com:4111/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively compiled…really just the king
of great languages.">Haskell</a>, <a href="http://home.jle0.com:4111/entries/category/@ramblings.html" class="tag-a-category" title="My slight ramblings on subjects of interest (to me and hopefully to you too!). Lots of surveys and
introducts to new subjects.">Ramblings</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>If you’ve spent your entire life programming imperatively, you could not even begin to imagine the vast worlds of thinking that are inaccessible because of restrictions in your thinking. Not “better”, or “harder” ways of thinking — possibly just as easy, but…different.</p>
<p>Don’t believe me? Here is an example of an amazingly awesome and amazing and incomprehensibly mind-opeining design pattern that shines in functional programming: applicative combinators. In specific, we are going to write a small parser library! Yay!</p>
<p>Now, if you are a sane person, you should know that <em>nobody</em> enjoys writing parsers…imperatively. The whole deal is a mess; you have to keep track of multiple layers of state, work out back tracking and edge cases, and to top it off, parsers tend to be very uncomposable, and parsing two different things usually requires either source code surgery in the best case or a complete rewrite in the worst.</p>
<p>But what if I told you that combinator-based parsers are so easy to work with and composable and intuitive that they are…well, fun? I’ll tease you:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- a parser for a special variable name, which can optionally start with an</span>
<span class="co">-- `@` symbol, and then an alphabet character, followed by many alphanumeric</span>
<span class="co">-- characters</span>
<span class="ot">variableName ::</span> <span class="dt">Parser</span> <span class="dt">String</span>
variableName <span class="fu">=</span> (optional <span class="ch">&#39;@&#39;</span>) <span class="fu">&lt;:&gt;</span> alpha <span class="fu">&lt;:&gt;</span> (many alphaNum)

<span class="co">-- usage:</span>
<span class="co">-- λ: parse variableName &quot;9one&quot;</span>
<span class="co">-- Nothing</span>
<span class="co">-- λ: parse variableName &quot;var01&quot;</span>
<span class="co">-- Just (&quot;var01&quot;, &quot;&quot;)</span>
<span class="co">-- λ: parse variableName &quot;@var2&quot;</span>
<span class="co">-- Just (&quot;@var2&quot;, &quot;&quot;)</span>
<span class="co">-- λ: parse variableName &quot;@9one&quot;</span>
<span class="co">-- Nothing</span></code></pre></div>
<p>Let’s take a look, shall we? We will first write our library, and then see how we build complex parsers out of smaller, simpler ones. And maybe learn a little bit of Haskell along the way — in particular, the magic of Functors and Applicative Functors (and maybe some Monads if we’re lucky).</p>
<p>(Much of this post is taken from a University of Göteborg <a href="http://www.cse.chalmers.se/edu/course/TDA452/FPLectures/Vid/">lecture series</a> available online; it has been slightly rephrased to be more applicative-centric than monad-centric)</p>
<h2 id="our-parser-type">Our Parser Type</h2>
<p>So; our goal here is to write a library for parsing that is powerful to be completely general and adaptable for any purpose. And also be very intuitive to use. Easy, right? Let’s start with the type of our Parser!</p>
<h3 id="our-parser-type-1">Our Parser type</h3>
<p>So our Parser type is going to be an object of type <code>Parser a</code> that contains one thing: a parsing function. This parsing function will take in a string and return the parsed value of type <code>a</code>, together with the “leftover” string that is unparsed.</p>
<p>In Haskell, we represent this object as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Parser</span> a <span class="fu">=</span> <span class="dt">P</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> (a, <span class="dt">String</span>))</code></pre></div>
<p>which reads “The type <code>Parser a</code> is an object that you specify by saying ‘<code>P f</code>’, where <code>f</code> is a function that takes in a string and returns an <code>a</code> with another string.</p>
<aside>
<pre><code>###### Aside</code></pre>
<p>Hi! These asides are for people unfamiliar with Haskell syntax. Feel free to skip them if you already are comfortable.</p>
If you’ve ever used an object-oriented language like Java or C++, <code>Parser a</code> is a template, or generic, and would be written in those languages as the class <code>Parser&lt;a&gt;</code>, with only one instance variable: a function taking a string and returning something of type <code>a</code> with a leftover string.
</aside>
<p>And we write a function <code>parse</code> that will take any <code>Parser a</code> object and any string, and return the parsed string:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">parse ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> (a, <span class="dt">String</span>)              <span class="co">-- 1</span>
parse (<span class="dt">P</span> f) str <span class="fu">=</span> f str                                 <span class="co">-- 2</span></code></pre></div>
<aside>
<pre><code>###### Aside</code></pre>
<p>A bunch of Haskell syntax features here!</p>
<ol type="1">
<li><p>This first line says “the function <code>parse</code> is a function that takes a <code>Parser a</code> and a <code>String</code> and return something of the value <code>(a, String)</code>”</p></li>
<li><p>Now to define the function. It has two arguments; the first one is of the form <code>P f</code>, and the second is just a string <code>str</code>. Remember, <code>P f</code> is how you specify a <code>Parser a</code>; the <code>f</code> is the function inside the object. We then call <code>f</code> with <code>str</code>, and that’s what we want.</p></li>
</ol>
</aside>
<p>Let’s say we had a parser <code>integerParser</code> pre-made, that parses a string into an integer. Here is how we would use it in the interactive <a href="http://en.wikipedia.org/wiki/Read-eval-print_loop">repl</a> prompt:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> <span class="fu">:</span><span class="kw">type</span> integerParser
<span class="ot">integerParser ::</span> <span class="dt">Parser</span> <span class="dt">Int</span>
λ<span class="fu">:</span> parse integerParser <span class="st">&quot;12&quot;</span>
(<span class="dv">12</span>, <span class="st">&quot;&quot;</span>)                    <span class="co">-- returns the integer 12, with nothing leftover</span>
λ<span class="fu">:</span> parse integerParser <span class="st">&quot;-82 zero&quot;</span>
(<span class="dv">82</span>, <span class="st">&quot; zero&quot;</span>)               <span class="co">-- returns the integer -82, with some leftovers</span>
λ<span class="fu">:</span> parse integerParser <span class="st">&quot;hello&quot;</span>
<span class="fu">??????</span>                      <span class="co">-- ??????</span></code></pre></div>
<aside>
<pre><code>###### Aside</code></pre>
<p>In this article, code that begins with <code>λ:</code> means stuff entered at the interactive prompt, ghci. You enter an expression, and it is evaluated, its result printed.</p>
<code>:type</code> is a ghci command that returns the type of the thing in question.
</aside>
<p>Hm. There’s a problem. Sometimes, the parse will fail. How can we indicate that a parse is failable?</p>
<p>In most languages, we might return a <code>nil</code> or <code>null</code> value. But this is not cool in Haskell because we like having type safety — having things be <code>nil</code> or <code>null</code> willy-nilly means that your compiler can’t help you, and you open up the door to runtime errors.</p>
<p>In Haskell, we have an object of type <code>Maybe a</code>, which can either be <code>Just a</code> (the object contains a value <code>a</code>), or <code>Nothing</code> (the object contains nothing). Let’s change our function so that it will return <code>Just a</code> if our parse succeeds and <code>Nothing</code> if it fails.</p>
<aside>
<pre><code>###### Aside</code></pre>
Again keeping with the analogies to Object-Oriented Programming, you can think of <code>Maybe a</code> as a superclass, <code>Maybe&lt;a&gt;</code>, with two subclasses: <code>Just a</code> and <code>Nothing</code>. <code>Just a</code> contains one instance variable of type <code>a</code>, and <code>Nothing</code> contains…nothing.
</aside>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Parser</span> a <span class="fu">=</span> <span class="dt">P</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">String</span>))

<span class="ot">parse ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">String</span>)
parse (<span class="dt">P</span> f) str <span class="fu">=</span> f str</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> parse integerParser <span class="st">&quot;12&quot;</span>
<span class="dt">Just</span> (<span class="dv">12</span>, <span class="st">&quot;&quot;</span>)               <span class="co">-- succesfully returns the integer 12, inside a</span>
                            <span class="co">-- Maybe object</span>
λ<span class="fu">:</span> parse integerParser <span class="st">&quot;-82 zero&quot;</span>
<span class="dt">Just</span> (<span class="fu">-</span><span class="dv">82</span>, <span class="st">&quot; zero&quot;</span>)         <span class="co">-- succesfully returns the integer -82</span>
λ<span class="fu">:</span> parse integerParser <span class="st">&quot;hello&quot;</span>
<span class="dt">Nothing</span>                     <span class="co">-- fails</span></code></pre></div>
<p>Okay, cool. Let’s get started.</p>
<h3 id="our-base-parsers">Our base parsers</h3>
<p>So remember, the whole point is to be able to somehow build complex parsers out of very simple ones. So let’s start with the simplest parsers of all: a parser that always fails.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">failure ::</span> <span class="dt">Parser</span> a
failure <span class="fu">=</span> <span class="dt">P</span> returnNothing                   <span class="co">-- 1</span>
    <span class="kw">where</span>
        returnNothing _ <span class="fu">=</span> <span class="dt">Nothing</span>           <span class="co">-- 2</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> parse failure <span class="st">&quot;12&quot;</span>
<span class="dt">Nothing</span>
λ<span class="fu">:</span> parse failure <span class="st">&quot;anything&quot;</span>
<span class="dt">Nothing</span></code></pre></div>
<aside>
<pre><code>###### Aside</code></pre>
<ol type="1">
<li>Remember, we specify/construct parsers as <code>P f</code>, where <code>f</code> is the parsing function.</li>
<li><code>_</code> is a wildcard in Haskell; <code>returnNothing</code> is a function that takes <em>anything</em> and returns <code>Nothing</code>.</li>
</ol>
</aside>
<p>Easy enough. How about some parsers that always succeeds with a pre-defined answer, and does not consume any of the string?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">successfulTrue ::</span> <span class="dt">Parser</span> <span class="dt">Bool</span>
successfulTrue <span class="fu">=</span> <span class="dt">P</span> returnTrue
    <span class="kw">where</span>
        returnTrue str <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">True</span>, str)

<span class="ot">succesfulZero ::</span> <span class="dt">Parser</span> <span class="dt">Int</span>
succesfulZero <span class="fu">=</span> <span class="dt">P</span> returnZero
    <span class="kw">where</span>
        returnZero str <span class="fu">=</span> <span class="dt">Just</span> (<span class="dv">0</span>, str)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> parse succesfulTrue <span class="st">&quot;12&quot;</span>
<span class="dt">Just</span> (<span class="dt">True</span>, <span class="st">&quot;12&quot;</span>)
λ<span class="fu">:</span> parse succesfulZero <span class="st">&quot;anything&quot;</span>
<span class="dt">Just</span> (<span class="dv">0</span>, <span class="st">&quot;anything&quot;</span>)</code></pre></div>
<p>We have two parsers here, with two different parse functions. If you notice, they pretty much do the same thing, and have very similar structure. This is a key flag that we can probably abstract out some part of it. Let’s write a new parse function that covers both of them:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">successful ::</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a
successful val <span class="fu">=</span> <span class="dt">P</span> returnVal
    <span class="kw">where</span>
        returnVal str <span class="fu">=</span> <span class="dt">Just</span> (val, str)

<span class="ot">succesfulTrue ::</span> <span class="dt">Parser</span> <span class="dt">Bool</span>
succesfulTrue <span class="fu">=</span> succesful <span class="dt">True</span>

<span class="ot">succesfulZero ::</span> <span class="dt">Parser</span> <span class="dt">Int</span>
succesfulZero <span class="fu">=</span> succesful <span class="dv">0</span></code></pre></div>
<p>So <code>successful val</code> is a function that takes any value and gives us a <code>Parser a</code> with the function <code>returnVal</code> — <code>returnVal str</code> yields a <code>Just</code> with the <code>val</code> we gave to <code>successful</code>, with the string untouched. Let’s try it out.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> parse (successful <span class="dv">5</span>) <span class="st">&quot;hello&quot;</span>
<span class="dt">Just</span> (<span class="dv">5</span>, <span class="st">&quot;hello&quot;</span>)
λ<span class="fu">:</span> parse (successful <span class="fl">8.26</span>) <span class="st">&quot;hello&quot;</span>
<span class="dt">Just</span> (<span class="fl">8.26</span>, <span class="st">&quot;hello&quot;</span>)
λ<span class="fu">:</span> <span class="fu">:</span><span class="kw">type</span> (successful <span class="dt">True</span>)
succesful <span class="dt">True</span><span class="ot"> ::</span> <span class="dt">Parser</span> <span class="dt">Bool</span></code></pre></div>
<p>Note that the type of <code>succesful True</code> is exactly the same type as our <code>succesfulTrue</code> function. Which is what we would expect. Our <code>succesful val</code> function takes a value and returns a parser that parses anything into that given value. So if we pass in <code>True</code>, it will return a parser/function that parses anything into <code>True</code>.</p>
<p>Okay, so our two base parses are nice, but it doesn’t sound like they are useful at all for any real parsing work. Let’s write our first somewhat-useful-kinda-maybe parser: <code>anyChar</code></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">anyChar ::</span> <span class="dt">Parser</span> <span class="dt">Char</span>
anyChar <span class="fu">=</span> <span class="dt">P</span> getFirst
    <span class="kw">where</span>
        getFirst (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Just</span> (x, xs)          <span class="co">-- 1</span>
        getFirst []     <span class="fu">=</span> <span class="dt">Nothing</span>               <span class="co">-- 2</span></code></pre></div>
<aside>
<pre><code>###### Aside</code></pre>
<ol type="1">
<li>If you call <code>getFirst</code> on a non-empty list, it will set the <code>x</code> to the first element and <code>xs</code> to the rest of the list. Kind of like in C, a string is just an alias for a list of characters. So <code>getFirst &quot;hello&quot;</code> will return <code>Just ('h', &quot;ello&quot;)</code>.</li>
<li>If you call <code>getFirst</code> on an empty list, it fails.</li>
</ol>
</aside>
<p>Let’s see it at work.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> parse anyChar <span class="st">&quot;h&quot;</span>
<span class="dt">Just</span> (<span class="ch">&#39;h&#39;</span>, <span class="st">&quot;&quot;</span>)
λ<span class="fu">:</span> parse anyChar <span class="st">&quot;hello&quot;</span>
<span class="dt">Just</span> (<span class="ch">&#39;h&#39;</span>, <span class="st">&quot;ello&quot;</span>)
λ<span class="fu">:</span> parse anyChar <span class="st">&quot;&quot;</span>
<span class="dt">Nothing</span></code></pre></div>
<p>So <code>anyChar</code> parses a string into a…character. That’s…kind of boring, admittedly. I’m sure you could have written something that parses a one-letter string into a character in any language without a problem…one that would parse <code>&quot;h&quot;</code>, the string, into <code>'h'</code>, the character.</p>
<p>Hm. Let’s try something else. Let’s try a parser that always fails <em>unless</em> the taken character satisfies a certain condition:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">z ::</span> <span class="dt">Parser</span> <span class="dt">Char</span>
z <span class="fu">=</span> <span class="dt">P</span> isA_z
    <span class="kw">where</span>
        isA_z (x<span class="fu">:</span>xs) <span class="fu">=</span>  <span class="kw">if</span> x <span class="fu">==</span> <span class="ch">&#39;z&#39;</span>
                            <span class="kw">then</span> <span class="dt">Just</span> (x, xs)
                            <span class="kw">else</span> <span class="dt">Nothing</span>
        isA_z []     <span class="fu">=</span>  <span class="dt">Nothing</span>

<span class="ot">lowercase ::</span> <span class="dt">Parser</span> <span class="dt">Char</span>
lowercase <span class="fu">=</span> <span class="dt">P</span> isLowercase
    <span class="kw">where</span>
        isLowercase (x<span class="fu">:</span>xs)  <span class="fu">=</span>   <span class="kw">if</span> isLower x
                                    <span class="kw">then</span> <span class="dt">Just</span> (x, xs)
                                    <span class="kw">else</span> <span class="dt">Nothing</span>
        isLowercase []      <span class="fu">=</span>   <span class="dt">Nothing</span></code></pre></div>
<p>Remember that Haskell’s built-in <code>Data.Char</code> module provides the function <code>isLower :: Char -&gt; Bool</code>, which is true if the given character is a lowercase letter and false otherwise.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> parse z <span class="st">&quot;not z&quot;</span>
<span class="dt">Nothing</span>
λ<span class="fu">:</span> parse lowercase <span class="st">&quot;A&quot;</span>
<span class="dt">Nothing</span>
λ<span class="fu">:</span> parse lowercase <span class="st">&quot;a&quot;</span>
<span class="dt">Just</span> (<span class="ch">&#39;a&#39;</span>, <span class="st">&quot;&quot;</span>)</code></pre></div>
<p>But wait! Like in the case for <code>succesful</code>, we notice a definite pattern…and we can abstract this out.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">satisfies ::</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span>
satisfies p <span class="fu">=</span> <span class="dt">P</span> passesPredicate
    <span class="kw">where</span>
        passesPredicate (x<span class="fu">:</span>xs) <span class="fu">=</span>  <span class="kw">if</span> p z
                                      <span class="kw">then</span> <span class="dt">Just</span> (x, xs)
                                      <span class="kw">else</span> <span class="dt">Nothing</span>
        passesPredicate []     <span class="fu">=</span>  <span class="dt">Nothing</span>


<span class="ot">z ::</span> <span class="dt">Parser</span> <span class="dt">Char</span>
z <span class="fu">=</span> satisfies (<span class="fu">==</span> <span class="ch">&#39;z&#39;</span>)

<span class="ot">lowercase ::</span> <span class="dt">Parser</span> <span class="dt">Char</span>
lowercase <span class="fu">=</span> satisfies isLower</code></pre></div>
<aside>
<pre><code>###### Aside</code></pre>
Similar in structure to <code>(*2)</code>, <code>(== 'z')</code> is a function that returns true if the input is equal to <code>'z'</code> and false otherwise. That is, <code>(== 'z') 'a'</code> is false, while <code>(== 'z') 'z'</code> is true.
</aside>
<p>Remember, just like in the case with <code>succesful</code>: <code>satisfies p</code> returns a <code>Parser Char</code> that fails unless the first character satisfies the given predicate <code>p</code>; <code>p</code> has to be a function from <code>Char</code> to <code>Bool</code> — a predicate on <code>Char</code>s. So then <code>satisfies isLower</code> returns a new parser with the predicate <code>isLower</code> as the “checker”.</p>
<p>Let’s try this out with some more built-in predicates from <code>Data.Char</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> parse (satisfies isAlpha) <span class="st">&quot;hello&quot;</span>
<span class="dt">Just</span> (<span class="ch">&#39;h&#39;</span>, <span class="st">&quot;ello&quot;</span>)
λ<span class="fu">:</span> parse (satisfies isDigit) <span class="st">&quot;123abc&quot;</span>
<span class="dt">Just</span> (<span class="ch">&#39;1&#39;</span>, <span class="st">&quot;23abc&quot;</span>)
λ<span class="fu">:</span> parse (<span class="fu">==</span> <span class="ch">&#39;a&#39;</span>) <span class="st">&quot;abc&quot;</span>
<span class="dt">Just</span> (<span class="ch">&#39;a&#39;</span>, <span class="st">&quot;bc&quot;</span>)</code></pre></div>
<p>In fact, some of these parsers are so useful, let’s name some:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">digit ::</span> <span class="dt">Parser</span> <span class="dt">Char</span>
digit <span class="fu">=</span> satisfies isDigit

<span class="ot">alphaNum ::</span> <span class="dt">Parser</span> <span class="dt">Char</span>
alphaNum <span class="fu">=</span> satisfies isAlphaNum

<span class="ot">alpha ::</span> <span class="dt">Parser</span> <span class="dt">Char</span>
alphaNum <span class="fu">=</span> satisfies isAlpha

<span class="ot">char ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span>
char c <span class="fu">=</span> satisfies (<span class="fu">==</span> c)</code></pre></div>
<p>The last one is particularly neat — it says “accept only the given character” — <code>char 'a'</code> generates a parser that succeeds only on the character <code>a</code>.</p>
<p>Note that we even can rewrite <code>anyChar</code> in terms of <code>satisfies</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">anyChar ::</span> <span class="dt">Parser</span> <span class="dt">Char</span>
anyChar <span class="fu">=</span> satisfies (const <span class="dt">True</span>)</code></pre></div>
<p>where <code>const True :: a -&gt; Bool</code> is a function that ignores all its input and always returns true no matter what. <code>anyChar</code> is a parser that will take any character, no matter what.</p>
<h3 id="now-were-cooking">Now we’re cooking</h3>
<p>Okay, so we are making baby steps. Here are our “base” parsers. They can’t really do much on their own; you can either always fail, always succeed, and parse any one-character string into a character. But the last one…the ability to <em>selectively</em> parse a string into a character…that might be interesting. It’s not totally obvious yet how we can make it useful, but…I think we have enough base parsers to start building our <em>combinators</em> — functions that combine and modify parsers.</p>
<h2 id="functors">Functors</h2>
<p>You have probably worked with functors before in your programming life with or without knowing it. Functors represent objects or data structures that “contain” data that can be “mapped over” — that is, functors are objects where you can apply functions to the values inside. The most famous functor in any language is the list, <code>[]</code>; another neat one is <code>Maybe</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> (<span class="fu">*</span><span class="dv">2</span>) <span class="fu">&lt;$&gt;</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
[<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>]
λ<span class="fu">:</span> (<span class="fu">*</span><span class="dv">2</span>) <span class="fu">&lt;$&gt;</span> <span class="dt">Just</span> <span class="dv">3</span>
<span class="dt">Just</span> <span class="dv">6</span></code></pre></div>
<aside>
<pre><code>###### Aside</code></pre>
<p>First of all, to clarify, <code>(*2)</code> is a function that doubles whatever is passed to it — <code>(*2) 3</code> is 6.</p>
<p>Next, in haskell, we can use the <code>&lt;$&gt;</code> operator to say “apply this…‘inside’ of the structure”. This is analogous to the more-often-used <code>$</code> operator:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> (<span class="fu">*</span><span class="dv">2</span>) <span class="fu">$</span> <span class="dv">3</span>
<span class="dv">6</span></code></pre></div>
<p>Which says “apply this (<code>(*2)</code>)…to this (<code>3</code>)”.</p>
<p>Compare that to:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> (<span class="fu">*</span><span class="dv">2</span>) <span class="fu">&lt;$&gt;</span> [<span class="dv">3</span>]
[<span class="dv">6</span>]
λ<span class="fu">:</span> (<span class="fu">*</span><span class="dv">2</span>) <span class="fu">&lt;$&gt;</span> <span class="dt">Just</span> <span class="dv">3</span>
<span class="dv">6</span></code></pre></div>
<p>As you can see, <code>&lt;$&gt;</code> is the “container” version of <code>$</code>. It is like <code>$</code>, but “inside”.</p>
<p>For more information, refer to adit’s <a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">amazing article</a> on the topic.</p>
</aside>
<p>You can probably see where I’m going with this.</p>
<h3 id="turning-our-parser-into-a-functor">Turning our Parser into a Functor</h3>
<h4 id="what-does-that-even-mean">What does that even mean?</h4>
<p>Hopefully you saw this coming. Functors seem to be very cool. But does it even make sense that our Parser object is a functor? The <code>Parser Int</code> object doesn’t “contain” any <code>Int</code>s…does it?</p>
<p>Well…it kind of “does”…in two ways, sorta kinda maybe.</p>
<ol type="1">
<li>You could say that a <code>Parser Int</code> “contains” the to-be-parsed integer.</li>
<li>You could say that a <code>Parser Int</code> “contains” the <strong>idea</strong> of an integer…abstractly. Like, whoa, man.</li>
</ol>
<p>So…does it make sense to apply a function “inside” a <code>Parser a</code>? The answer is yes!</p>
<ol type="1">
<li>If a <code>Parser Int</code> contains a to-be-parsed integer, then applying a function inside a <code>Parser Int</code> would be like applying the function to the to-be-parsed integer!</li>
<li>If a <code>Parser Int</code> contains the <em>idea</em> of an integer, then applying a function inside a <code>Parser Int</code> would be applying the function to the idea of the integer.</li>
</ol>
<p>Huh. This is kinda cool, isn’t it? So let’s say that when we apply a function “inside” our Parser…it means that we apply a function to the finished result of a succesful parse.</p>
<p>Basically, we want something like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> <span class="kw">let</span> succesfulSix <span class="fu">=</span> (<span class="fu">*</span><span class="dv">2</span>) <span class="fu">&lt;$&gt;</span> (succesful <span class="dv">3</span>)
λ<span class="fu">:</span> <span class="fu">:</span><span class="kw">type</span> succesfulSix
<span class="ot">succesfulSix ::</span> <span class="dt">Parser</span> <span class="dt">Int</span>
λ<span class="fu">:</span> parse succesfulSix <span class="st">&quot;something&quot;</span>
<span class="dt">Just</span> <span class="dv">6</span></code></pre></div>
<p>Okay, cool. So instead of <code>succesful 3</code> always succeeding with a 3, it succeeds with <code>(*2) 3</code>, which is 6. Still kinda boring but w/e.</p>
<p>Let’s try something else…we’re going to take advantage of the <code>Data.Char</code> method <code>digitToInt :: Char -&gt; Int</code>, which takes a <code>Char</code> and returns the digit that it represents (for example, <code>digitToInt '5'</code> is 5, the integer):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> <span class="kw">let</span> digitInt <span class="fu">=</span> digitToInt <span class="fu">&lt;$&gt;</span> digit      <span class="co">-- 1</span>
λ<span class="fu">:</span> <span class="fu">:</span><span class="kw">type</span> digitInt
<span class="ot">digitInt ::</span> <span class="dt">Parser</span> <span class="dt">Int</span>
λ<span class="fu">:</span> parse digitInt <span class="st">&quot;2&quot;</span>
<span class="dt">Just</span> (<span class="dv">2</span>, <span class="st">&quot;&quot;</span>)
λ<span class="fu">:</span> parse digitInt <span class="st">&quot;a&quot;</span>
<span class="dt">Nothing</span></code></pre></div>
<ol type="1">
<li>Remember, we defined the parser <code>digit</code> earlier, as a parser that only succeeds if the first character is a digit.</li>
</ol>
<p>Did you just see that? That sounds genuinely useful! If we manage to implement <code>&lt;$&gt;</code> properly, we just have a way to selectively parse any digit character into a digit, and fail otherwise.</p>
<p>Let’s try chaining <code>&lt;$&gt;</code>’s:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> <span class="kw">let</span> digitIntDoubled <span class="fu">=</span> (<span class="fu">*</span><span class="dv">2</span>) <span class="fu">&lt;$&gt;</span> (digitToInt <span class="fu">&lt;$&gt;</span> digit)
λ<span class="fu">:</span> <span class="fu">:</span><span class="kw">type</span> digitIntDoubled
<span class="ot">digitIntDoubled ::</span> <span class="dt">Parser</span> <span class="dt">Int</span>
λ<span class="fu">:</span> parse digitIntDoubled <span class="st">&quot;2&quot;</span>
<span class="dt">Just</span> (<span class="dv">4</span>, <span class="st">&quot;&quot;</span>)
λ<span class="fu">:</span> parse digitIntDoubled <span class="st">&quot;a&quot;</span>
<span class="dt">Nothing</span></code></pre></div>
<p>What just happened here?</p>
<ol type="1">
<li><code>digit</code> is a parser that succeeds only on digit characters.</li>
<li><code>digitToInt &lt;$&gt; digit</code> is the result of applying <code>digitToInt</code> on the value of a succesful parse. Basically, <code>digitToInt &lt;$&gt; digit</code> is a <em>new parser</em> that succeeds on digit characters, returning an integer.</li>
<li><code>(*2) &lt;$&gt; (digitToInt &lt;$&gt; digit)</code> is the result of applying <code>(*2)</code> (the doubling function) to <code>digitToInt &lt;$&gt; digit</code>, the return-digit-as-int parser. The <code>(*2) &lt;$&gt;</code> doubles the result of the return-digit-as-int parser. Essentially, the entire expression is a <em>new parser</em> that succeeds on digit character, returning the doubled integer as the parse result.</li>
</ol>
<p>*Phew*. That was a conceptual doozy. But this seems like a good path. Do you see what we did? We turned old, boring parsers into new, interesting parsers by “transforming” them. This is the kind of thing we were looking for in the first place, right?</p>
<h4 id="implementing-the-functor-instance">Implementing the Functor instance</h4>
<p>That’s all fine and dandy. Now we have to actually implement <code>&lt;$&gt;</code>.</p>
<p>Luckily in Haskell, there are mechanisms for uniting functor interfaces. That is, if you tell it that <code>Parser a</code> is a functor, then you open up all sorts of powerful functor tools that were written for things like lists and maybe’s — now we can use them all on <code>Parser a</code>, too.</p>
<p>To do this, we “instance” the Functor <em>typeclass</em>. A typeclass in Haskell is like an interface in Object-Oriented Programming. Basically, we say “<code>Parser a</code> is a functor…treat it like one!” But in order to make it a valid functor, we must tell it how to <code>fmap</code>. <code>fmap</code> is basically <code>&lt;$&gt;</code> — it takes a function, a functor object, and returns a new functor object with that function applied “inside”. Once we define <code>fmap</code>, then we get <code>&lt;$&gt;</code> for free. Or rather, Haskell knows that our parser is a functor, and knows how to use <code>&lt;$&gt;</code> on functors.</p>
<p>Here’s how we do it. Hold on tight!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Parser</span> <span class="kw">where</span>                                       <span class="co">-- 1</span>
    fmap f parser <span class="fu">=</span> <span class="dt">P</span> mapped_parser_function                        <span class="co">-- 2</span>
        <span class="kw">where</span>

<span class="ot">            unmapped_result ::</span> <span class="dt">Maybe</span> (a, <span class="dt">String</span>)
            unmapped_result <span class="fu">=</span> parse parser str                      <span class="co">-- 3</span>

<span class="ot">            mapped_parser_function ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (b, <span class="dt">String</span>)
            mapped_parser_function str <span class="fu">=</span>
                <span class="kw">case</span> unmapped_result <span class="kw">of</span>                             <span class="co">-- 4</span>
                    <span class="dt">Just</span> (result, rest) <span class="ot">-&gt;</span> <span class="dt">Just</span> (f result, rest)    <span class="co">-- 5</span>
                    <span class="dt">Nothing</span>             <span class="ot">-&gt;</span> <span class="dt">Nothing</span>                  <span class="co">-- 6</span></code></pre></div>
<aside>
<pre><code>###### Aside</code></pre>
<ol type="1">
<li>This line is syntax for “we are declaring that <code>Parser</code> is a functor!”, so that Haskell can treat <code>Parser</code> like a functor (and have <code>&lt;$&gt;</code> work).</li>
<li>In order to declare something as a functor, we must define the function <code>fmap :: (a -&gt; b) -&gt; Parser a -&gt; Parser b</code>, which takes a function from <code>a</code> to <code>b</code>, a <code>Parser a</code>, and returns the mapped-over parser/parser with the function applied “inside”.</li>
<li>Grab the result of the parse with the unmapped parser, first.</li>
<li>Some more Haskell syntax. Basically, the result of <code>mapped_parser_function</code> is dependent on what <code>unmapped_result</code> is.</li>
<li>If <code>unmapped_result</code> is a <code>Just</code>, then return the success, but apply <code>f</code> to the result first.</li>
<li>If <code>unmapped_result</code> is <code>Nothing</code>…well, you can’t apply anything to the result if the result is a failure (a <code>Nothing</code>). Pass on the failure.</li>
</ol>
</aside>
<p>And now we can use our <code>Parser a</code> as a functor; all of our use cases above will now work.</p>
<h3 id="fun-with-functors">Fun with functors</h3>
<p>Let’s take a brief moment to see what kind of things we can do with only functors, and nothing else. It’s probably not going to be too much more useful than what you can write imperatively, but it is interesting what you can do by only ‘modifying’ simpler parsers…which is what the whole point of combinators are.</p>
<p>With that in mind, let’s try out some neat use cases.</p>
<p>What if you want to parse a digit and look it up in a list of keywords, and return that keyword?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">keywords ::</span> [<span class="dt">String</span>]
keywords <span class="fu">=</span> [<span class="st">&quot;debug&quot;</span>,<span class="st">&quot;normal&quot;</span>,<span class="st">&quot;warning&quot;</span>,<span class="st">&quot;error&quot;</span>]

<span class="ot">digit ::</span> <span class="dt">Parser</span> <span class="dt">Char</span>
digit <span class="fu">=</span> satisfies isDigit

<span class="ot">digitInt ::</span> <span class="dt">Parser</span> <span class="dt">Int</span>
digitInt <span class="fu">=</span> digitToInt <span class="fu">&lt;$&gt;</span> digit

<span class="ot">keyword ::</span> <span class="dt">Parser</span> <span class="dt">String</span>
keyword <span class="fu">=</span> (<span class="fu">!!</span> keywords) <span class="fu">&lt;$&gt;</span> digitInt</code></pre></div>
<aside>
<pre><code>###### Aside</code></pre>
<code>(!! keywords)</code> is a function that looks up the given index in the given list. In our case, <code>(!! keywords) 2</code> would return what in other languages is <code>keywords[2]</code>, which is the string “warning”.
</aside>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> parse keyword <span class="st">&quot;1&quot;</span>
<span class="dt">Just</span> (<span class="st">&quot;normal&quot;</span>, <span class="st">&quot;&quot;</span>)
λ<span class="fu">:</span> parse keyword <span class="st">&quot;hello&quot;</span>
<span class="dt">Nothing</span></code></pre></div>
<!-- ~~~haskell -->
<!-- λ: parse keyword "1" -->
<!-- Just ("normal", "") -->
<!-- λ: parse keyword "hello" -->
<!-- Nothing -->
<!-- λ: parse keyword "67" -->
<!-- *** Exception: (!!): index too large -->
<!-- ~~~ -->
<!-- Oops!  We forgot that `!!` is an unsafe/partial function (it is undefined for -->
<!-- some inputs)...it should have been obvious becuase `!!` is a pretty -->
<!-- unsafe-looking name for a function.  It tried to find index 6 of the -->
<!-- list...but that index doesn't exist. -->
<!-- There are ways to take care of that kind of sloppily, but what we want is a -->
<!-- function that takes a parser, a condition (the number has to be less than -->
<!-- four, for instance), and returns a new parser with that condition built-in. -->
<!-- Some spoilers --- an object that has this ability is known as a "monad". Let's -->
<!-- keep this in mind as we move forward with our applicative parsers. --></div><footer><ul class="entry-series"></ul><ul class="tag-list"><li><a href="http://home.jle0.com:4111/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="http://home.jle0.com:4111/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="http://home.jle0.com:4111/entries/category/@ramblings.html" class="tag-a-category">@RAMBLINGS</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="http://home.jle0.com:4111/entry/looking-forward-a-doctorate-program.html">Looking forward: A Doctorate Program</a> (Previous)</li><li class="next-entry-link">(Next) <a href="http://home.jle0.com:4111/entry/auto-building-a-declarative-chatbot-with-implicit-serialization.html">Auto: Building a declarative chat bot with implicit serialization</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://home.jle0.com:4111/entry/functional-programming-is-awesome-parser-combinators.html';
    this.page.identifier = 'combinators-parsers';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//justinleblogdevelopment.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2016 Justin Le</div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-facebook" title="Friend me on Facebook!" href="https://facebook.com/mstksg">Facebook</a></li><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="https://coinbase.com/mstksg">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/justinleblogdevelopment">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=justinleblogdevelopment">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>