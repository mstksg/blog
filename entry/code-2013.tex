\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Justin Le},
            pdftitle={Code 2013},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

\title{Code 2013}
\author{Justin Le}
\date{January 9, 2014}

\begin{document}
\maketitle

\emph{Originally posted on \textbf{\href{http://home.jle0.com:4111/entry/code-2013.html}{in Code}}.}

It's a bit late, but, inspired by my own admittedly egregious
\href{https://twitter.com/mstk/status/418179201091399680}{tweet} in participation of the awesome
\href{http://code2013.herokuapp.com/}{\#code2013} hashtag, here is a review of 2013 in terms of the
programming languages I've worked on and a general wrap-up of the adventures that 2013 had to offer
me. It was quite surely the most productive/adventurous year of programming of my entire life.

\section{Scientific Computing}\label{scientific-computing}

This year was the year I began to take scientific computing seriously. I had already been using
\textbf{\href{http://www.wolfram.com/mathematica/}{Mathematica}} for many years, for some basic
modeling work on analytic and numeric systems. This year continued my studies; however, I also
enrolled in a two-quarter class taught by the Physics department (my own field of study) at my
university on scientific computing techniques and applications in the context of Computational
Physics.

However, this course would be relying heavily on parallel computing techniques as well as low-level
compiled languages like C and Fortran, with simulations that would have decently long executing
times.

\subsection{Linux}\label{linux}

I quickly realized that I could not do very much with my little Windows laptop, so I procured for
the first time in my life a persistent server. I used the lowest tier from
\href{http://www.togglebox.com/}{ToggleBox}, a great cloud hosting service that gave me a year free.
This was my return to unix-based systems after a break of several years, and in doing this I sort of
went crazy again writing several
\textbf{\href{http://en.wikipedia.org/wiki/Bash_(Unix_shell)}{Bash}} scripts that I am continuing to
\href{http://blog.jle.im/entry/log-sh-lightweight-command-line-note-logging}{open-source}/publish
today; many of my scripts revolved around the \href{http://todotxt.com/}{todo.txt} framework.

I did some work on parsing some of my custom journal entry files and things like that, and with this
I returned to using \textbf{\href{http://en.wikipedia.org/wiki/Awk}{awk}}, which I had worked with a
few years ago for processing logs. I rather really liked the language and it seemed like a very
perfectly adapted DSL. There are many problems that are solved most easily in awk and I have a lot
of respect for the language.

\subsection{Vim}\label{vim}

Also this year was the year I decided to begin taking vi/\href{http://www.vim.org/}{vim} seriously.
This is because I realized that I would be doing most of my coding through an ssh connection, so I
needed to pick a good terminal editor. After a lot of research I settled on vim. I've been
exclusively using vim for some time now and, while it has a lot of endearing flaws, I am happy with
my choice. With a toolbelt of plugins and extensions as well as a firm grasp of the vanilla basics,
vim has served me very well. I have even delved into some of my own personal plugin development in
\textbf{\href{http://en.wikipedia.org/wiki/Vim_script}{vimscript}}

\subsection{Computation}\label{computation}

For the aforementioned course, we had the opportunity to use either C or Fortran. Because I had
dabbled in C before and have worked in C-like languages all my life, I figured I would take the
opportunity to learn a new language. So I learned
\textbf{\href{http://en.wikipedia.org/wiki/Fortran}{Fortran}} --- specifically, F77. This decision
ended up being a good one because many of the established numerical/computational libraries in
Physics were written in the seventies, and almost all of them are in Fortran. This interoperability
was very handy, and I was also able to dive into them and pick them apart.

Upon further digging into Fortran I found that I actually really liked the semantics and syntax of
the language. The language seemed to fit to the computational techniques and algorithms I was
learning about like a glove, more so than with C or C++. Many things that felt awkward in C felt
natural in Fortran, and the entire program execution model just seemed seamless and elegant.

I still consider Fortran among my favorite imperative languages today.

However, for group projects I was forced to work with
\textbf{\href{http://en.wikipedia.org/wiki/C++}{C++}}, specifically with its
\href{http://www.nvidia.com/object/cuda_home_new.html}{Cuda} hooks, on a parallel N-body simulation.
I came to appreciate the ad-hoc binary serialization of data structures that many languages I had
been using in the past lacked.

And here is the appropriate time to mention my work in
\textbf{\href{http://www.gnuplot.info/}{gnuplot}} for the presentation of the data generated by
these course projects

In another course on numerical analysis, there was much usage also of
\textbf{\href{http://www.mathworks.com/products/matlab/}{Matlab}}, if only to demonstrate certain
theorems and techniques. In addition to this, for some of my lab courses, I did much of my data
analysis and modeling/presentation in matlab.

\subsection{Java}\label{java}

I also took a beginning \textbf{\href{https://www.java.com/en/}{Java}} course during my spring
quarter. Mostly to fill in some requirements for my degree, I didn't actually learn too much. This
section is just to make this post complete :) My most recent large-ish work on Java was for a
Machine Learning/Artificial Intelligence course the year before. No new insights from Java gleamed
this year that I can post here\ldots{}except that I can appreciate in a perverse way Java's
stubbornness to keep a consistent story of
\href{http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html}{nouns}.

\section{Haskell}\label{haskell}

Around the end of winter I stumbled upon
\textbf{\href{http://www.haskell.org/haskellwiki/Haskell}{Haskell}}. I am not completely sure how,
actually. Perhaps it is just fate. But it is probably one of the more significant life-changing
discoveries of my programming life. This event will define the rest of my entire year; it also
inspired this blog itself. Haskell is a beautifully expressive functional, pure, non-strict language
that merges serious and practical programming and powerful mathematics. Writing fully about my
reflections on Haskell is beyond the scope of this post. However, if you don't yet know Haskell, why
don't you give \href{http://learnyouahaskell.com/}{Learn You A Haskell} a quick read? :) You won't
regret it!

I began with trying to implement my Fortran Monte Carlo programs in Haskell for my course. I wasn't
quite skilled enough to really use the full power of Haskell before my computation course ended, I
was able to really simplify my programs and appreciate even a small part of the elegance of Haskell.

\subsection{Blog}\label{blog}

Over the summer I delved back into web development by deciding that my next big Haskell project
would be a blog engine. The result is this blog!

Actually, I have noticed that, more than for other languages, having and maintaining a blog is a
rite of passage and is sort or embedded into the culture of the Haskell community. I also noticed
that a lot of the work I was doing was novel in the sense that I couldn't find any real established
literature; I had to forge a lot of the way myself. I wanted to be able to be able to give back to
the community (which is, by the way, one of the best programming language communities I have found)
and maybe jot down some of these struggles or observations.

(This is probably also the best place to drop my usage of
\textbf{\href{http://www.graphviz.org/}{graphviz}}'s \emph{dot} DSL for some diagrams for some blog
posts. I like it a lot actually, and its declarative model is pretty useful.)

(Oh yes I found myself learning and using some \textbf{\href{http://en.wikipedia.org/wiki/SQL}{SQL}}
for this if only to better understand how to write joins in
\href{http://hackage.haskell.org/package/esqueleto}{Esqueleto})

\section{Web Development}\label{web-development}

I made a couple of forays into Web Development this year. This blog was one, but there was very
little front-end development work actually.

I made some small toy projects on \textbf{\href{https://www.ruby-lang.org/en/}{ruby}} on my favorite
framework, \href{http://www.sinatrarb.com/}{Sinatra}. These are mostly just simple file server and
organization apps and GUI front-ends for native compiled programs (simulations and the like). These
all involved somewhat minimal front-end
\textbf{\href{http://en.wikipedia.org/wiki/JavaScript}{javascript}} and are styled with
\textbf{\href{http://sass-lang.com/}{sass}}, a CSS pre-processor that I was at first hesitant to use
but am not more or less completely dependent on. (Maybe that was the reason I was hesitant in the
first place? Oh well!)

I actually really enjoy ruby; before Haskell, it was my favorite language for many years and my
go-to scripting and one-off language. I also tended to ``think'' in ruby whenever approaching
programming problems. I'll always have a sort of nostalgic attachment to ruby, and in many cases you
can't beat its expressiveness and utility as a scripting language right off the bat (something that
it gains from its perl influences).

Some time in the fall, \href{http://www.intuit.com/}{Intuit} came to my university and hosted a
Hackathon. My team ended up rapidly prototyping our app using ruby with the
\href{http://rubyonrails.org/}{Rails} framework. So this is my most recent web dev adventure. This
was actaully my first time using Rails, despite having used ruby for many years. The experience was
sort of disorienting, much magic. A lot felt very un-ruby. I guess I'll be sticking with Sinatra for
now :)

\section{Engineering}\label{engineering}

I had a summer job working at a Physics lab doing control theory work in the field of electrical
engineering. Much of it was in Matlab, especially with the visual ``language'' of
\textbf{\href{http://www.mathworks.com/products/simulink/}{Simulink}}. I used
\textbf{\href{http://www.ni.com/labview/}{LabVIEW}} extensively as well; I guess I didn't count
those in my tweet but they probably deserve more recognition than graphviz at least.

Simulink is a pretty amazing simulation system and I understand that it is very effectively used in
its industry fields. I was able to do a lot with its platform and ecosystem right out of the box
that would have taken much time to shoddily replicate in another language. Its integration with
Matlab (and compiled Matlab) makes it extremely powerful for a very wide range of control
applications. Wow.

I also worked a lot on the \href{http://arduino.cc/}{Arduino} platform, using
\textbf{\href{http://en.wikipedia.org/wiki/C_(programming_language)}{C}}. It was very nice to work
with. This is before I really knew much about dynamic memory allocation, but the work I did (simple
image processing and pattern recognition alongside startup procedures) did not require it.

\section{Fall Courses}\label{fall-courses}

\subsection{C/C++ Course}\label{cc-course}

I took a data structures in C and C++ course in the fall. It was pleasant because while I had
dabbled in both, I actually had very little formal education. I was able to formalize my
understanding of pointer-based data structures (in C) and the syntax, language semantics, and
language philosophy of C++, being able to structure someone more-than-toy projects. I consider this
my first real exposure to formal C++ and manual dynamic memory management (without the use of a
garbage collector), and I gained a lot from slowing down to figure this all out.

\subsection{Comparative Programming Languages
Course}\label{comparative-programming-languages-course}

And now the final chapter!

In my fall quarter I took my university's comparative programming languages course.

\subsubsection{OCaml}\label{ocaml}

The first language we went into was \textbf{\href{http://ocaml.org/}{OCaml}}, a member of the
(typically) functional, strict, impure ML family of languages. Learning it was a pleasant experience
that helped me appreciate the advances in language development that lead to Haskell. I was able to
more formalized what I liked and didn't like about Haskell. I grew an appreciation for Haskell's IO
model; I also thought it was interesting that OCaml did not have the stubborn insistence on making
type notation mirror data notation that Haskell does. The Haskell tuple \texttt{(Int,\ Int)} is the
OCaml tuple \texttt{int\ *\ int}; the Haskell type application \texttt{Maybe\ Int} is in OCaml
\texttt{int\ maybe}. It gets rid of a lot of the confusion cased by mixing up type constructors and
data constructors in Haskell. But having the two be parallel does alow for some interesting
reasoning, and it also allows us to deal with Kinds in the same way that we deal with Types.

But I'm getting a bit ahead of myself! And I am going on a tangent. There are a lot of interesting
differences between OCaml and Haskell :)

The culmination of our work in OCaml was using ocamlyacc to write an interpreter of a simple subset
of a functional language. It was a nice contrast to how in Haskell we typically write our own
parsers using parser combinators instead of outsourcing to a ``compiled'' DSL.

\subsubsection{Python}\label{python}

Our next language was python! I do not have many good things to say about this language :P I was
always sort of a ruby fanboy. I have a long list of complaints about python from a language design
standpoint. But I'm here to praise its benefits. The idiomatic usage of decorators was something
interesting and very python-esque. The object/class model was interesting in contrast to Javascript,
Ruby, Java/C\#, etc. There, I was nice :)

\subsubsection{Prolog}\label{prolog}

(\href{http://www.swi-prolog.org/}{SWI-})\textbf{\href{http://en.wikipedia.org/wiki/Prolog}{Prolog}}
was exciting to work with. I had a lot of fun with it. I'll just put
\href{http://c2.com/cgi/wiki?PrologLanguage}{this quote} here:

\begin{quote}
I used Prolog in a comparative languages course. The biggest program we did was a map-coloring one
(color a map with only four colors so that no bordering items have the same color, given a mapping
of things that border each other). I say biggest because we were given the most time with it. I
started out like most people in my class trying to hack the language into letting me code a stinking
algorithm to color a stinking map. Then I wrote a test function to check if the map was colored and,
in a flash of prolog, realized that that was really all I needed to code.
\end{quote}

Really though, the language was a nice joy. I talked to some people about bigger applications and I
read up on a way to run a web server with Prolog. It was a little interesting but I felt like at
some point the language model might start interfering with its usages, instead of in Haskell where
the language model enhances much of its usage. Maybe that was just because I hadn't tried it enough.
Still, Prolog remains a great (domain specific?) language for solving constraint problems and logic
problems. Perhaps I will give it more of a look some time in the future!

\section{2013 in Review}\label{in-review}

Welp, that's it! My observations on the languages I used this year, sort of patched together to tell
the story of my programming adventures this year.

What were some of your own adventures this year, in relation to new/old languages?

\end{document}
